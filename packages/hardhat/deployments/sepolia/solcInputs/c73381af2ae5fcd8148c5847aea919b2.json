{
  "language": "Solidity",
  "sources": {
    "contracts/AimEvaluator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {IAIOracle} from \"../lib/OAO/contracts/interfaces/IAIOracle.sol\";\nimport {AIOracleCallbackReceiver} from \"../lib/OAO/contracts/AIOracleCallbackReceiver.sol\";\n\n/// @notice Contract that stores a constitution and evaluates proposals against it using AI\ncontract AimEvaluator is AIOracleCallbackReceiver {\n    event ConstitutionUpdated(address updater, uint256 timestamp);\n    \n    event ProposalEvaluated(\n        uint256 requestId,\n        address proposer,\n        string proposal,\n        string result\n    );\n    \n    struct ProposalRequest {\n        address proposer;\n        string proposal;\n        string result;\n        bool completed;\n    }\n    \n    address public owner;\n    \n    // Constitution storage\n    string public constitution;\n    bool public constitutionSet;\n    \n    // Default to Llama model ID\n    uint256 public evaluationModelId = 11;\n    uint64 public callbackGasLimit = 5_000_000;\n    \n    // Track proposal requests\n    mapping(uint256 => ProposalRequest) public proposals;\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n    \n    /// @notice Initialize the contract with the AI Oracle address\n    constructor(IAIOracle _aiOracle) AIOracleCallbackReceiver(_aiOracle) {\n        owner = msg.sender;\n    }\n    \n    /// @notice Set or update the constitution\n    function setConstitution(string calldata newConstitution) external onlyOwner {\n        constitution = newConstitution;\n        constitutionSet = true;\n        emit ConstitutionUpdated(msg.sender, block.timestamp);\n    }\n    \n    /// @notice Clear the constitution\n    function clearConstitution() external onlyOwner {\n        constitution = \"\";\n        constitutionSet = false;\n        emit ConstitutionUpdated(msg.sender, block.timestamp);\n    }\n    \n    /// @notice Update model settings\n    function updateModelSettings(uint256 modelId, uint64 gasLimit) external onlyOwner {\n        evaluationModelId = modelId;\n        callbackGasLimit = gasLimit;\n    }\n    \n    /// @notice OAO callback function that processes the AI response\n    function aiOracleCallback(uint256 requestId, bytes calldata output, bytes calldata callbackData) external override onlyAIOracleCallback() {\n        ProposalRequest storage request = proposals[requestId];\n        require(request.proposer != address(0), \"Request does not exist\");\n        \n        // Store the result\n        request.result = string(output);\n        request.completed = true;\n        \n        // Emit an event with the evaluation result\n        emit ProposalEvaluated(\n            requestId,\n            request.proposer,\n            request.proposal,\n            request.result\n        );\n    }\n    \n    /// @notice Get the fee estimate for proposal evaluation\n    function estimateFee() public view returns (uint256) {\n        return aiOracle.estimateFee(evaluationModelId, callbackGasLimit);\n    }\n    \n    /// @notice Submit a proposal to be evaluated against the constitution\n    function evaluateProposal(string calldata proposal) payable external returns (uint256) {\n        require(constitutionSet, \"Constitution not set\");\n        \n        // Build the prompt for the AI\n        string memory fullPrompt = string(abi.encodePacked(\n            \"You are a constitutional evaluator. Evaluate the following proposal strictly according to this constitution and respond with ONLY 'approved' or 'declined' and nothing else.\\n\\nCONSTITUTION:\\n\",\n            constitution,\n            \"\\n\\nPROPOSAL TO EVALUATE:\\n\",\n            proposal\n        ));\n        \n        // Send request to the AI Oracle\n        uint256 requestId = aiOracle.requestCallback{value: msg.value}(\n            evaluationModelId, \n            bytes(fullPrompt), \n            address(this), \n            callbackGasLimit, \n            \"\"\n        );\n        \n        // Store proposal information\n        proposals[requestId] = ProposalRequest({\n            proposer: msg.sender,\n            proposal: proposal,\n            result: \"\",\n            completed: false\n        });\n        \n        return requestId;\n    }\n    \n    /// @notice Check the result of a proposal evaluation\n    function getProposalResult(uint256 requestId) external view returns (string memory proposal, string memory result, bool completed) {\n        ProposalRequest storage request = proposals[requestId];\n        require(request.proposer != address(0), \"Request does not exist\");\n        \n        return (request.proposal, request.result, request.completed);\n    }\n}"
    },
    "lib/OAO/contracts/AIOracleCallbackReceiver.sol": {
      "content": "// SampleContract.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./interfaces/IAIOracle.sol\";\n\n/// @notice A base contract for writing a AIOracle app\nabstract contract AIOracleCallbackReceiver {\n\n    // Address of the AIOracle contract\n    IAIOracle public immutable aiOracle;\n\n    // Invalid callback source error\n    error UnauthorizedCallbackSource(IAIOracle expected, IAIOracle found);\n\n    /// @notice Initialize the contract, binding it to a specified AIOracle contract\n    constructor(IAIOracle _aiOracle) {\n        aiOracle = _aiOracle;\n    }\n\n    /// @notice Verify this is a callback by the aiOracle contract \n    modifier onlyAIOracleCallback() {\n        IAIOracle foundRelayAddress = IAIOracle(msg.sender);\n        if (foundRelayAddress != aiOracle) {\n            revert UnauthorizedCallbackSource(aiOracle, foundRelayAddress);\n        }\n        _;\n    }\n\n    /**\n     * @dev the callback function in OAO, should add the modifier onlyAIOracleCallback!\n     * @param requestId Id for the request in OAO (unique per request)\n     * @param output AI model's output\n     * @param callbackData user-defined data (The same as when the user call aiOracle.requestCallback)\n     */\n    function aiOracleCallback(uint256 requestId, bytes calldata output, bytes calldata callbackData) external virtual;\n\n    function isFinalized(uint256 requestId) external view returns (bool) {\n        return aiOracle.isFinalized(requestId);\n    }\n}"
    },
    "lib/OAO/contracts/interfaces/IAIOracle.sol": {
      "content": "// SampleContract.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IAIOracle {\n    /// @notice Event emitted upon receiving a callback request through requestCallback.\n    event AICallbackRequest(\n        address indexed account,\n        uint256 indexed requestId,\n        uint256 modelId,\n        bytes input,\n        address callbackContract,\n        uint64 gasLimit,\n        bytes callbackData\n    );\n\n    /// @notice Event emitted when the result is uploaded or update.\n    event AICallbackResult(\n        address indexed account,\n        uint256 indexed requestId,\n        address invoker,\n        bytes output\n    );\n\n    /**\n     * initiate a request in OAO\n     * @param modelId ID for AI model\n     * @param input input for AI model\n     * @param callbackContract address of callback contract\n     * @param gasLimit gas limitation of calling the callback function\n     * @param callbackData optional, user-defined data, will send back to the callback function\n     * @return requestID\n     */\n    function requestCallback(\n        uint256 modelId,\n        bytes memory input,\n        address callbackContract,\n        uint64 gasLimit,\n        bytes memory callbackData\n    ) external payable returns (uint256);\n\n    function estimateFee(uint256 modelId, uint256 gasLimit) external view returns (uint256);\n\n    function isFinalized(uint256 requestId) external view returns (bool);\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}